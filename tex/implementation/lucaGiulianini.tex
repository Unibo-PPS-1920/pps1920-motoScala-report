% -*- root: ../../main.tex -*-
\section{Luca Giulianini}
Lo studente Luca Giulianini si è occupato delle seguenti macro-parti:
\begin{itemize}
	\item{\textbf{Architettura generale e mediazione MVC-ECS}}
	\item{\textbf{Architettura ECS}}
	\item{\textbf{Architettura View}}
	\item{\textbf{Continuous Integration e configurazione dei Build-Tools}}
\end{itemize}

inoltre ha contribuito al lavoro dei colleghi svolgendo una serie di \textbf{micro-task}.

\subsubsection{Approfondimenti}

Parallelamente all'esperienza di progetto sono stati approfonditi una serie di argomenti relativi al mondo di \textbf{Scala} e della \textbf{programmazione funzionale}. 
\begin{itemize}
	\item{\textbf{Monadi:}} è stato chiarito il concetto astratto di \textbf{Monade}.
	\item{\textbf{Pogrammazione funzionale:}} è stato approfondito l'insieme delle \textbf{buo-ne pratiche} relative alla programmazione funzionale. Questo è stato fatto seguento svariate \textbf{conferenze} dedicate al mondo Scala e appoggiandosi a una serie di \textbf{libri} dedicati. 
	\item{\textbf{Refined Types:}} Molto utili nella fase di \textbf{validazione statica e dinamica} di input. Attualmente non utilizzati data la natura del progetto in questione.
	\item{\textbf{Monix e Akka Streams:}} È stato approfondito il mondo della programmazione \textbf{reattiva} focalizzandosi maggiormente sulle differenze fra il framework \texttt{Monix} e \texttt{Akka Streams}.
\end{itemize}

\subsubsection{Risorse}

Gli approfondimenti sono stati svolti grazie all'utilizzo delle seguenti risorse:
\begin{itemize}
	\item{\textbf{Libri:}}
	\begin{itemize}
		\item{\textbf{Learning Scala \cite{scalaLearning:2014}:}} libro che riassume interamente le \textbf{principali features} del linguaggio Scala in ambito \textbf{funzionale}. È stato usato per consolidare alcune conoscenze pregresse.
		\item{\textbf{Programming in Scala \cite{scalaBook:2014}:}} rappresenta la bibbia di Scala ed è stato scritto dal grandissimo \textbf{Martin Odersky}.
		\item{\textbf{Scala with Cats \cite{scalaCats:2020}:}} libro che copre gli aspetti più \textbf{avanzati} del linguaggio Scala dal punto di vista \textbf{funzionale}. Per ogni singolo aspetto è fornita una \textbf{definizione teorica} e la relativa implementazione nella libreria ufficiale \href{https://typelevel.org/cats-effect/}{\texttt{Cats}}. È un libro particolarmente \textbf{complesso} ed è stato utilizzato come approfondimento.
		\item{\textbf{Scala Cookbook \cite{scalaCook:2013}:}} I \textbf{Cookbook} di O'Reilly sono conosciuti per essere estremamente \textbf{pragmatici}. Anche in questo caso il libro si configura come un'\textbf{enciclopedia del problem solving} dedicata interamente al linguaggio Scala.
		\item{\textbf{Functional Programming in Scala \cite{functionalScala:2014}:}} davvero una grande scoperta. Questo libro rappresenta un insieme di \textbf{buone pratiche} e \textbf{aspetti teorici} che ogni programmatore Scala dovrebbe conoscere. Personalmente di grande utilità sono stati i capitoli che trattano la \textbf{gestione degli errori} e gli aspetti funzionali più avanzati (\texttt{monoids, monads} e \texttt{applicative functors}).  
	\end{itemize}
	\item{\textbf{Conferenze:}}
	\begin{itemize}
		\item{\textbf{Scala Days:}}
		Sono le conferenze ufficiali di Scala che ogni anno hanno luogo in un paese diverso. I talk proposti sono estremamente interessanti e permettono di apprendere un gran numero di \textbf{tecniche avanzate} e sopratutto costituiscono un ottimo esempio di \textbf{buona programmazione}.
		Conferenze consigliate:
		\begin{itemize}
			\item{\emph{\href{https://www.youtube.com/watch?v=CrpJJYPzdJE&t=630s}{Akka Streams to the Extreme - Heiko Seeberger}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=pHHKUKubs1Q&t=2002s}{Migrating to Scala 2.13 by Julien Richard Foy and Stefan Zeiger}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=DGa58FfiMqc}{Scala best practices I wish someone'd told me about - Nicolas Rinaudo}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=I6pFxyL9Crc}{ScalaClean - full program static analysis at scale - Rory Graves}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=TqJg4AuxEIQ}{Concurrent programming in 2019: Akka, Monix or ZIO? - Adam Warski}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=_Rnrx2lo9cw}{A Tour of Scala 3 - Martin Odersky}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=wfbF5jQiAhQ}{Security with Scala Refined Types and Object Capabilities by Will Sargent}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=30q6BkBv5MY}{Functional Programming with Effects by Rob Norris}}}
		 \end{itemize} 
		\item{\textbf{Scalapeño:}} come dice il nome stesso, sono \textbf{conferenze piccanti} che hanno lo scopo di smuovere le acque all'interno della comunità di Scala.
		Conferenze consigliate:
		\begin{itemize}
			\item{\emph{\href{https://www.youtube.com/watch?v=v8IQ-X2HkGE}{The Last Hope for Scala's Infinity War - John A. De Goes}}}
			\item{\emph{\href{https://www.youtube.com/watch?v=Arwb6DSrWXE&t=102s}{Scala vs. Kotlin, friend or foe? - Ohad Shai}}}
		 \end{itemize} 
	\end{itemize}
\end{itemize}


\subsection{Architettura generale e mediazione MVC-ECS}
\subsubsection{Progettazione}
La definizione di una architettura generale ha richiesto un grande sforzo dal punto di vista del \textbf{design}. I principali problemi da risolvere sono stati essenzialmente i seguenti:
\begin{itemize}
	\item{\textbf{Interazione MVC-ECS:}} il problema in questo caso risiede nella \textbf{natura architetturale} dei due \textbf{pattern}. Essi generalmente sono utilizzati \textbf{singolarmente} per plasmare una applicazione e una possibile \textbf{integrazione} con altri pattern avrebbe potuto portare a \textbf{seri conflitti}.
	\item{\textbf{Estendibilità al modello client-server:}} l'idea architetturale fondante, per quanto riguarda l'intero applicativo, è sempre stata diretta verso la definizione di un \textbf{core funzionante} espandibile attraverso \textbf{moduli client-server} (attori). L'idea è stata sicuramente ambiziosa ma ha portato con se una serie di problemantiche non banali a livello interazionale. Infatti, sviluppare un \textbf{core} \textbf{modulare} e \textbf{dinamico} in base alla tipologia di interazione richiede un alto tasso di ingegnerizzazione e \textbf{anticipazione del cambiamento}.
\end{itemize}
\paragraph{La Soluzione}
La soluzione come già anticipato in \ref{sec:mediator_design} è consistita nella defini-zione di un oggetto di tipo \texttt{publish/subscribe} (il \texttt{Mediator}) capace di \textbf{mediare i flussi di dati} fra un numero di oggetti indefinito.

\subsubsection{Implementazione}
\paragraph{Approccio ad Handlers}
L'implementazione del \texttt{Mediator} è stata inizialmente incentrata su una architettura basata su \textbf{handlers} ad \textbf{eventi} (vedi \ref{fig:mediatorHandler}). L'architettura però ha da subito presentato alcune \textbf{lacune} molto gravi fra le quali spicca l'impossibilità di poter \textbf{rimuovere facilmente handlers relativi a un subscriber}. Per questo motivo si è deciso di sacrificare un briciolo di performance e puntare maggiormente su una architettura più \textbf{pulita} e \textbf{stabile} basata su \textbf{Observers}.

\paragraph{Approccio ad Observers}
Questo approccio si basa essenzialemnte sul modello proposto dal \textbf{Pattern Observer}. Nel caso proposto però la parte\\ { }\texttt{Observable} è stata incapsulata all'interno di un unico elemento, il \texttt{Mediator}. Così facendo il \texttt{Mediator} si configura come \textbf{unico punto di snodo} capace di \textbf{osservare} e \textbf{ridirigere} gli eventi verso l'\texttt{Observer} \textbf{appropriato} (\textbf{Subscriber}). La ridirezione è svolta osservando il \textbf{tipo dell'evento} in \textbf{entrata} e il tipo dell'evento al quale un \texttt{Observer} \textbf{è interessato}. Ogni \texttt{Observer} è interessato a tutti gli eventi che sono \textbf{covarianti} rispetto al tipo di evento al quale si sono \textbf{sottoscritti} (vedi \ref{lst:listato1})

\lstinputlisting[caption={Mediator}, label=lst:listato1]{code/mediator.scala}

Per quanto riguarda la definizione degli eventi, si è deciso di utilizzare un approccio basato su \texttt{Algebraic Data Type} grazie al quale è possibile definire una gerarchia di eventi (vedi \ref{lst:listato2})

\lstinputlisting[caption={Event}, label=lst:listato2]{code/event.scala}

\subsubsection{Contributi e validazioni}
\begin{itemize}
	\item{\textbf{Gyordan Caminati:}} l'implementazione del \texttt{Mediator} tramite l'utilizzo di \texttt{Observers} è stata \textbf{validata} da Gyordan Caminati. Inoltre Gyordan ha fornito un \textbf{contributo} molto importante nella \textbf{risoluzione di un problema} riscontrato durante l'utilizzo di \textbf{reflections} in Scala. 
\end{itemize}


\subsection{Architettura ECS}
\subsubsection{Progettazione}
La fase di progettazione relativa ad ECS è consistita in un \textbf{processo di continuo raffinamento}, iniziato prendendo spunto da alcuni \textbf{articoli proposti in rete} e concluso con una \textbf{soluzione} estremamente \textbf{pulita} e \textbf{concisa}. 

\paragraph{Composition over Inheritance}
Personalmente la sfida più grande in questo caso è consistita nel trovare un design che permettesse di ottenere una \textbf{buona estendibilità} mantenendo allo stesso tempo delle \textbf{buone performance}. Si è passati così alla definizione di un modello \textbf{data-driven}, molto vicino ad una \textbf{visione funzionale}. Come vediamo in \ref{fig:ECS} si è deciso di spostare l'intera architettura verso un approccio basato su \textbf{composizione}, molto \textbf{estendibile} e \textbf{manutenibile}. 

\paragraph{Managers}
L'intera \textbf{logica di gestione} è stata spostata \textbf{al di fuori} delle entità in gioco, all'interno di moduli dedicati chiamati \texttt{Manager}. Ogni manager è caratterizzato da un \textbf{insieme ridotto di operazioni} dedicate a \textbf{gestire} e \textbf{connettere} al più due \textbf{tipologie} di oggetti. Per esempio un \texttt{ComponentManager} è in grado di gestire solamente \texttt{Component} e per farlo mette in relazione ad essi anche delle \texttt{Entity}.

\paragraph{Coordinator}
Poichè la gestione di singoli \texttt{Manager} separatamente produrrebbe un \textbf{design frammentato} e difficilmente controllabile, è stato deciso di \textbf{coordinare} quest'ultimi grazie ad un unico modulo che prende il nome appunto di\\ \texttt{Coordinator}.

\subsubsection{Implementazione}
L'implementazione dell'architettura di \texttt{ECS} è risultata estramente \textbf{lineare} e \textbf{non si è discostata} di molto da ciò che era stato \textbf{progettato}.

\subsubsection{Contributi e validazioni}
\begin{itemize}
	\item{\textbf{Ruben Ceroni:}} l'implementazione dell'architettura di \texttt{ECS} è stata \textbf{validata} da Ruben Ceroni il quale ha \textbf{contribuito a spingere} verso lo sviluppo di una \textbf{soluzione} basata su \textbf{managers}.
\end{itemize}


\subsection{Architettura View}
\subsection{Continuous Integration e configurazione dei Build-Tools}
\subsection{Micro-task}
